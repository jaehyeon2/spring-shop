#Spring Data JPA
##JPA?
- ORM 기술의 표준 형태로 자바에서 제공하는 API

###Strength
1. 특정 데이터베이스에 종속되지 않음
   - 설정 파일에 사용 데이터베이스를 작성하면 데이터베이스 변경 가능
2. 객체지향적 프로그래밍
   - 데이터베이스 설계 중심의 패러다임에서 객체지향적으로 설계가 가능
   - 직관적이고 비즈니스로직에 집중 가능
3. 생산성 향상
   - 테이블과 매핑된 클래스에 필드만 추가한다면 쉽게 관리가 가능
   - Query문을 직접 사용하지 않고 객체를 사용하여 동작하기 떄문에 유지보수, 재사용성이 좋음
###Weakness
1. 복잡한 쿼리 처리
   - 통계 처리 같은 복잡한 쿼리를 사용할 경우는 SQL문을 사용하는 것이 좋음
   - SQL과 유사한 JPQL을 지원함
2. 성능 저하 위험
   - 객체 간의 매핑 설계를 잘못했을 때 성능 저하가 발생할 수 있음
   - 자동으로 생성하는 쿼리가 많기 때문에 의도하지 않는 쿼리로 인해 성능이 저하될 수 있음

###동작 방식
####Entity
- 데이터베이스의 테이블에 대응하는 클래스/@Entity가 붙은 클래스는 JPA에서 관리
####Entity Manager Factory
- 엔티티 매니저 인스턴스를 관리하는 주체
- 애플리캐이션 실행 시 한 개만 만들어지며 사용자로부터 요청이 오면 엔티티 매니저 팩토리로부터 엔티티 매니저를 생성
####Entity Manager
- 영속성 컨첵스트에 접근하여 엔티티에 대한 데이터베이스 작업을 제공
- 메소드
  - find() : 영속성 컨텍스트에서 엔티티를 검색하고 영속성 컨텍스트에 없을 경우 데이터베이스에서 데이터를 찾아 영속성 컨텍스트에 저장
  - persist() : 엔티티를 영속성 컨텍스트에 저장
  - remove() : 엔티티 클래스를 영속성 컨텍스트에서 삭세
  - flush() : 영속성 컨텍스트에 저장된 내용을 데이터베이스에 반영
####영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 역할
- advantage
  - 1차 캐시
    - Map<KEY, VALUE>로 저장, entityManager.find() 호출 시 영속성 컨텍스트의 1차 캐시를 조회
    - 엔티티가 존재할 경우 해당 엔티티를 반환하고,
    - 엔티티가 없다면 데이터베이스에서 조회 후 1차 캐시에 반환
  - 동일성 보장
    - 하나의 트랜잭션에서 같은 키값으로 영속성 컨텍스트에 저장된 엔티티 조회 시 같은 엔티티 조회를 보장
    - 1차 캐시에 저장된 엔티티를 조회하기 때문에 가능
  - 트랜잭션을 지원하는 쓰기 지원
    - 쓰기 지연 SQL 저장소가 존재
    - entityManager.persist() 호출 시 1차 캐시 저장과 동시에 SQL 저장소에 SQL문이 저장
  - 변경 감지
    - 1차 캐시의 엔티티와 스냅샷을 비교 후 변경내용이 있으면 UPDATE SQL문을 쓰기 지연 SQL에 저장
    - DB 커밋 시점에 변경내용을 자동으로 반영
###MySQL 연결 설정
- DB에 연결하기 위해 mysql jdbc driver를 설정
- 연결할 DB의 URL, 포트, DB이름을 입력
  - spring.datasource.hikari.jdbc-url=jdbc:mysql://{url}:{port}/{db}
- DB id, password 입력
- DB 초기화 전략 - DDL AUTO 옵션
  - spring.jpa.hibernate.ddl-auto
    - none: 사용하지 않음
    - create: 기존 테이블 삭제 후 테이블 생성
    - create-drop: 기존 테이블 삭제 후 테이블 생성, 종료 시점에 테이블 삭제
    - update: 변경된 스키마 적용
    - validate: 엔티티와 테이블 정상 매핑 확인
